暂停功能，没有考虑到离线的情况下

离线就报错就行了

之前是用

补充下，如果是上传的分片文件返回失败的话，就停止上传，因为失败的大部分原因是服务器的问题或者网络问题，那么也就没有必要再重新上传了

## [不太实用的进度事件](https://zh.javascript.info/resume-upload#bu-tai-shi-yong-de-jin-du-shi-jian)

要恢复上传，我们需要知道在连接丢失前已经上传了多少。

我们有 `xhr.upload.onprogress` 来追踪上传进程。

不幸的是，它在这里没什么作用，它在数据发送 **sent** 完成时触发，但是它真的被服务器接收了吗？浏览器并不知道。

或许它只是被本地代理缓冲（buffered），或是有可能远程服务器处理进程宕机无法处理它们，亦或是当连接断开时它刚刚从中间丢失，且没有到达服务器。

因此，这个事件只是对于显示一个漂亮的进度条来说很有用。

要恢复上传，我们需要知道服务器具体接收了多少字节。只有服务器能告诉我们它接收了多少。



## webworker不知道怎么内部关闭

##  webworker传值

前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。

主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。

> ```javascript
> 
> ```

但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做[Transferable Objects](http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects)。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。

如果要直接转移数据的控制权，就要使用下面的写法。



## 引入webworker

webworker创建有两种方式，一种是引入外部js,还有一种是用就是脚本字符串的方式
1.
`new Worker('worker.js')`
2.

```
var blob = new Blob([document.querySelector('#worker').textContent]); // textContent为字符串脚本
var url = window.URL.createObjectURL(blob);
var worker = new Worker(url);

```

react中引入外部js会报错，可以考虑使用第二种方式创建Worker





# 0815

### 任务 文件上传模块(进度75%)

完成重试功能，web端今天还没什么成果

今天主要花时间在调试暂停，重试的网络离线情况，修改了之前的代码方案，之前是一个文件上传过程中，有一个分片请求失败的话，其他的分片文件也会继续上传，但考虑到失败的大部分原因是服务器的问题或者网络问题，那么也就没有必要再重新上传，因为失败的概率很大，所以如果是上传的分片文件返回失败的话，之后的文件就停止上传，

### 问题

1. 发现当离线时，即使请求失败，事件ajax的upload的process的进度也会继续到变为100，这个问题还没解决，明天再看axios有没有关于这方面的处理

   ```
   if (xhr.upload) {
         xhr.upload.onprogress = function progress(e) {
           if (e.total > 0) {
             e.percent = (e.loaded / e.total) * 100;
           }
           option.onProgress(e);
         };
       }
   ```

   

2. 上传大文件的时候暂停的时候，假设发出去的第一次请求队列进度是到20，但是按了暂停，请求取消，重新开始，重新发送请求，所以真实进度为0，因为后端只保存整个分片上传成功的数据，这样的话用户体验感不好，所以保留了原先的进度20，但是如果网络很慢的情况下，页面进度就想卡住一样，因为在等请求进度达到原来的20,这个问题就先保留着，没有想出更好的方案

   